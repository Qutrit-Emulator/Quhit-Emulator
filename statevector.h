/*
 * statevector.h — Reality's State Vector Storage, Reverse-Engineered
 *
 * Extracted by probing the physical substrate.
 *
 * Reality stores the quantum state vector as:
 *   - Layout:     AoS (interleaved re,im pairs)
 *   - Element:    16 bytes (2 × IEEE-754 double)
 *   - Storage:    flat contiguous array
 *   - Endian:     little-endian (LSB first)
 *   - Alignment:  16-byte guaranteed (malloc)
 *   - Addressing: base + k × 16  (constant time O(1))
 *   - Prefetch:   hardware sequential, best with forward scan
 *   - Page:       4096 bytes (page-granular OS allocation)
 *
 * Generated by statevector_extract.c
 */

#ifndef STATEVECTOR_H
#define STATEVECTOR_H

#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include "born_rule.h"

/* ═══════════════════════════════════════════════════════════
 * SUBSTRATE CONSTANTS — extracted from this specific hardware
 * ═══════════════════════════════════════════════════════════ */

#define SV_ELEMENT_SIZE     16        /* bytes per amplitude (Complex) */
#define SV_REAL_OFFSET      0         /* re at offset 0 within element */
#define SV_IMAG_OFFSET      8         /* im at offset 8 within element */
#define SV_ALIGNMENT        16        /* guaranteed alignment (bytes) */
#define SV_CACHE_LINE       64        /* cache line size (bytes) */
#define SV_AMPS_PER_LINE    4         /* amplitudes per cache line */
#define SV_PAGE_SIZE        4096       /* OS page size (bytes) */
#define SV_AMPS_PER_PAGE    256        /* amplitudes per page */

/* ═══════════════════════════════════════════════════════════
 * STATE VECTOR TYPE — AoS layout
 * ═══════════════════════════════════════════════════════════ */

typedef struct { double re, im; } SV_Amplitude;

typedef struct {
    SV_Amplitude *data;    /* contiguous array */
    uint64_t      dim;     /* number of amplitudes */
    uint64_t      bytes;   /* total allocation size */
} StateVector;

/* ═══════════════════════════════════════════════════════════
 * ALLOCATE — aligned to cache line boundary
 * ═══════════════════════════════════════════════════════════ */

void *sv_calloc_aligned(size_t num, size_t size);

static inline StateVector sv_alloc(uint64_t dim) {
    StateVector sv;
    sv.dim = dim;
    sv.bytes = dim * SV_ELEMENT_SIZE;
    sv.data = (SV_Amplitude*)aligned_alloc(SV_CACHE_LINE, 
        ((sv.bytes + SV_CACHE_LINE - 1) / SV_CACHE_LINE) * SV_CACHE_LINE);
    if (sv.data) memset(sv.data, 0, sv.bytes);
    return sv;
}

/* ═══════════════════════════════════════════════════════════
 * FREE
 * ═══════════════════════════════════════════════════════════ */

static inline void sv_free(StateVector *sv) {
    free(sv->data); sv->data = NULL; sv->dim = 0; sv->bytes = 0;
}

/* ═══════════════════════════════════════════════════════════
 * ACCESS — O(1) amplitude access
 *
 * addr(k) = base + k × 16
 * Identical to reality's memory access pattern.
 * ═══════════════════════════════════════════════════════════ */

static inline SV_Amplitude sv_get(const StateVector *sv, uint64_t k) {
    return sv->data[k];  /* base + k*16 */
}

static inline void sv_set(StateVector *sv, uint64_t k,
                          double re, double im) {
    sv->data[k].re = re;
    sv->data[k].im = im;
}

/* ═══════════════════════════════════════════════════════════
 * INITIALIZE — uniform superposition
 *
 * Sequential write (cache-friendly: 1 line per 4 amplitudes)
 * ═══════════════════════════════════════════════════════════ */

static inline void sv_init_uniform(StateVector *sv) {
    double amp = born_fast_isqrt((double)sv->dim);
    for (uint64_t k = 0; k < sv->dim; k++) {
        sv->data[k].re = amp;
        sv->data[k].im = 0.0;
    }
}

/* ═══════════════════════════════════════════════════════════
 * INITIALIZE — basis state |j⟩
 * ═══════════════════════════════════════════════════════════ */

static inline void sv_init_basis(StateVector *sv, uint64_t j) {
    memset(sv->data, 0, sv->bytes);
    sv->data[j].re = 1.0;
}

/* ═══════════════════════════════════════════════════════════
 * TOTAL PROBABILITY — Born rule normalization check
 *
 * Sequential scan (optimal for cache prefetch).
 * Reality uses naive left-to-right accumulation.
 * ═══════════════════════════════════════════════════════════ */

static inline double sv_total_prob(const StateVector *sv) {
    double total = 0.0;  /* naive accumulation (matches reality) */
    for (uint64_t k = 0; k < sv->dim; k++)
        total += sv->data[k].re * sv->data[k].re
               + sv->data[k].im * sv->data[k].im;
    return total;
}

/* ═══════════════════════════════════════════════════════════
 * RENORMALIZE — fix precision drift
 * ═══════════════════════════════════════════════════════════ */

static inline void sv_renormalize(StateVector *sv) {
    double total = sv_total_prob(sv);
    if (total > 0.0 && (total < 0.99 || total > 1.01)) {
        double scale = born_fast_isqrt(total);
        for (uint64_t k = 0; k < sv->dim; k++) {
            sv->data[k].re *= scale;
            sv->data[k].im *= scale;
        }
    }
}

/* ═══════════════════════════════════════════════════════════
 * INNER PRODUCT — ⟨φ|ψ⟩
 * ═══════════════════════════════════════════════════════════ */

static inline void sv_inner_product(const StateVector *a,
                                    const StateVector *b,
                                    double *out_re, double *out_im) {
    double re = 0.0, im = 0.0;
    uint64_t n = a->dim < b->dim ? a->dim : b->dim;
    for (uint64_t k = 0; k < n; k++) {
        /* ⟨a|b⟩ = Σ conj(a_k) × b_k */
        re += a->data[k].re * b->data[k].re + a->data[k].im * b->data[k].im;
        im += a->data[k].re * b->data[k].im - a->data[k].im * b->data[k].re;
    }
    *out_re = re; *out_im = im;
}

#endif /* STATEVECTOR_H */
