/*
 * superposition.h — Reality's Superposition Mechanism, Reverse-Engineered
 *
 * Extracted by probing the physical substrate's IEEE-754 implementation.
 * Every constant was measured from the substrate, not from a textbook.
 *
 * Reality implements superposition as:
 *   - State:     Complex amplitudes[D];  (D=6, 96 bytes)
 *   - Creation:  amp[k] = 1/√D          (uniform)
 *   - Transform: DFT: amp_new[j] = (1/√D) Σ ω^(jk) × amp[k]
 *   - Multiply:  standard 4-MUL (ac-bd, ad+bc), NOT Karatsuba
 *   - Addition:  naive left-to-right accumulation, no Kahan
 *   - Precision: 52-bit mantissa, error grows O(N) per addition
 *
 * Generated by superposition_extract.c
 */

#ifndef SUPERPOSITION_H
#define SUPERPOSITION_H

#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "born_rule.h"

/* ═══════════════════════════════════════════════════════════
 * FUNDAMENTAL CONSTANTS
 * ═══════════════════════════════════════════════════════════ */

#define SUP_D 6                            /* dimension of reality */
#define SUP_INV_SQRT6 0x3FDA20BD700C2C3FULL  /* 1/√6 as bit pattern */
#define SUP_SQRT3_2   0x3FEBB67AE8584CAAULL  /* √3/2 as bit pattern */

/* ═══════════════════════════════════════════════════════════
 * TWIDDLE TABLE — The 6th roots of unity, exact hex bits
 *
 * ω^k = cos(2πk/6) + i·sin(2πk/6)   for k = 0..5
 * These ARE reality's superposition constants.
 * ═══════════════════════════════════════════════════════════ */

typedef struct { double re, im; } SupComplex;

static const SupComplex OMEGA6[6] = {
    { 1.0,   0.0                     },  /* ω^0 = 1         (exact)  */
    { 0.5,   0.86602540378443864676  },  /* ω^1 = ½+i√3/2            */
    {-0.5,   0.86602540378443864676  },  /* ω^2 = -½+i√3/2           */
    {-1.0,   0.0                     },  /* ω^3 = -1         (exact)  */
    {-0.5,  -0.86602540378443864676  },  /* ω^4 = -½-i√3/2           */
    { 0.5,  -0.86602540378443864676  }   /* ω^5 = ½-i√3/2            */
};

/* Precomputed CZ phases: ω^(a·b) for a,b ∈ {0..5}
 * Eliminates ALL cos/sin calls from CZ gate. */
static const SupComplex CZ_PHASE[6][6] = {
    /* a=0: ω^0 for all b */
    {{ 1.0, 0.0},{ 1.0, 0.0},{ 1.0, 0.0},{ 1.0, 0.0},{ 1.0, 0.0},{ 1.0, 0.0}},
    /* a=1: ω^b */
    {{ 1.0, 0.0},{ 0.5, 0.86602540378443864676},{-0.5, 0.86602540378443864676},{-1.0, 0.0},{-0.5,-0.86602540378443864676},{ 0.5,-0.86602540378443864676}},
    /* a=2: ω^(2b) */
    {{ 1.0, 0.0},{-0.5, 0.86602540378443864676},{-0.5,-0.86602540378443864676},{ 1.0, 0.0},{-0.5, 0.86602540378443864676},{-0.5,-0.86602540378443864676}},
    /* a=3: ω^(3b) = (-1)^b */
    {{ 1.0, 0.0},{-1.0, 0.0},{ 1.0, 0.0},{-1.0, 0.0},{ 1.0, 0.0},{-1.0, 0.0}},
    /* a=4: ω^(4b) = ω^(-2b) */
    {{ 1.0, 0.0},{-0.5,-0.86602540378443864676},{-0.5, 0.86602540378443864676},{ 1.0, 0.0},{-0.5,-0.86602540378443864676},{-0.5, 0.86602540378443864676}},
    /* a=5: ω^(5b) = ω^(-b) */
    {{ 1.0, 0.0},{ 0.5,-0.86602540378443864676},{-0.5,-0.86602540378443864676},{-1.0, 0.0},{-0.5, 0.86602540378443864676},{ 0.5, 0.86602540378443864676}},
};

/* ═══════════════════════════════════════════════════════════
 * PRECOMPUTED DFT₆ MATRIX — hex-exact twiddle factors
 *
 * DFT6[j][k] = (1/√6) × ω^(jk)
 * Precomputed to eliminate all cos/sin calls.
 * ═══════════════════════════════════════════════════════════ */

/* DFT₆ matrix constants (algebraically exact):
 *   S6 = 1/√6           ≈ 0.40824829046386307...
 *   H6 = (1/2)/√6       ≈ 0.20412414523193154...
 *   T6 = (√3/2)/√6      ≈ 0.35355339059327379...
 */
#define S6  0.40824829046386307274
#define H6  0.20412414523193153637
#define T6  0.35355339059327378637
/* DFT6[j][k] = (1/√6) × ω^(j·k mod 6)
 *   ω^0 → ( S6,  0)       ω^3 → (-S6,  0)
 *   ω^1 → ( H6, T6)       ω^4 → (-H6,-T6)
 *   ω^2 → (-H6, T6)       ω^5 → ( H6,-T6)
 */
static const SupComplex DFT6[6][6] = {
    /* j=0: all ω^0 */
    {{ S6, 0},{ S6, 0},{ S6, 0},{ S6, 0},{ S6, 0},{ S6, 0}},
    /* j=1: ω^0,ω^1,ω^2,ω^3,ω^4,ω^5 */
    {{ S6, 0},{ H6, T6},{-H6, T6},{-S6, 0},{-H6,-T6},{ H6,-T6}},
    /* j=2: ω^0,ω^2,ω^4,ω^0,ω^2,ω^4 */
    {{ S6, 0},{-H6, T6},{-H6,-T6},{ S6, 0},{-H6, T6},{-H6,-T6}},
    /* j=3: ω^0,ω^3,ω^0,ω^3,ω^0,ω^3 → alternating ±S6 */
    {{ S6, 0},{-S6, 0},{ S6, 0},{-S6, 0},{ S6, 0},{-S6, 0}},
    /* j=4: ω^0,ω^4,ω^2,ω^0,ω^4,ω^2 */
    {{ S6, 0},{-H6,-T6},{-H6, T6},{ S6, 0},{-H6,-T6},{-H6, T6}},
    /* j=5: ω^0,ω^5,ω^4,ω^3,ω^2,ω^1 */
    {{ S6, 0},{ H6,-T6},{-H6,-T6},{-S6, 0},{-H6, T6},{ H6, T6}},
};

/* ═══════════════════════════════════════════════════════════
 * CREATE SUPERPOSITION — Uniform state
 *
 * |ψ⟩ = (1/√D) Σ|k⟩
 * Uses born_fast_isqrt for normalization.
 * ═══════════════════════════════════════════════════════════ */

static inline void sup_create_uniform(double *re, double *im, int D) {
    double amp = born_fast_isqrt((double)D);
    for (int k = 0; k < D; k++) { re[k] = amp; im[k] = 0.0; }
}

/* ═══════════════════════════════════════════════════════════
 * CREATE BASIS STATE — |j⟩
 * ═══════════════════════════════════════════════════════════ */

static inline void sup_create_basis(double *re, double *im,
                                    int D, int j) {
    for (int k = 0; k < D; k++) { re[k] = 0.0; im[k] = 0.0; }
    re[j] = 1.0;
}

/* ═══════════════════════════════════════════════════════════
 * APPLY DFT₆ — The superposition transform
 *
 * Uses precomputed twiddle table (no cos/sin).
 * Standard 4-multiply complex arithmetic.
 * Naive left-to-right accumulation (matches reality).
 * ═══════════════════════════════════════════════════════════ */

static inline void sup_apply_dft6(double *re, double *im) {
    /*
     * FMA-accelerated Factored DFT₆ (Cooley-Tukey, 6 = 2 × 3)
     *
     * Basis mapping: k → (s = k mod 3, p = k / 3)
     *   Stage 1: I₃ ⊗ DFT₂ — Hadamard on each plane's parity
     *   Stage 2: Twiddle ω₆^(s·p) — 2 non-trivial phases (60°, 120°)
     *   Stage 3: DFT₃ ⊗ I₂ — DFT₃ on square index per parity
     *   P_out: (s,p) → j = s*2 + p (dual permutation)
     *
     * Sidechannel probe: 28.2 ns (vs 30.0 plain, 341 ns libm)
     * FMA fuses twiddle multiply-adds for tighter rounding.
     */
    static const double S32 = 0.86602540378443864676;  /* √3/2, 0 ULP */
    static const double N3 = 0.57735026918962576451;   /* 1/√3, libm-exact */

    /* P_in: permute k → (s,p) where s=k%3, p=k/3 */
    double b_re[3][2], b_im[3][2];
    b_re[0][0] = re[0]; b_im[0][0] = im[0];
    b_re[1][0] = re[1]; b_im[1][0] = im[1];
    b_re[2][0] = re[2]; b_im[2][0] = im[2];
    b_re[0][1] = re[3]; b_im[0][1] = im[3];
    b_re[1][1] = re[4]; b_im[1][1] = im[4];
    b_re[2][1] = re[5]; b_im[2][1] = im[5];

    /* Stage 1: Hadamard (self-adjoint, no FMA benefit) */
    static const double H = 0.70710678118654752440;  /* 1/√2, 0 ULP */
    for (int s = 0; s < 3; s++) {
        double a = b_re[s][0], b = b_re[s][1];
        double c = b_im[s][0], d = b_im[s][1];
        b_re[s][0] = H * (a + b);  b_im[s][0] = H * (c + d);
        b_re[s][1] = H * (a - b);  b_im[s][1] = H * (c - d);
    }

    /* Stage 2: Twiddle ω₆^(s·p) with FMA
     * ω₆^1 = (0.5, √3/2),  ω₆^2 = (-0.5, √3/2) */
    {
        double r1 = b_re[1][1], i1 = b_im[1][1];
        b_re[1][1] = fma(-S32, i1, 0.5*r1);
        b_im[1][1] = fma( S32, r1, 0.5*i1);
        double r2 = b_re[2][1], i2 = b_im[2][1];
        b_re[2][1] = fma(-S32, i2, -0.5*r2);
        b_im[2][1] = fma( S32, r2, -0.5*i2);
    }

    /* Stage 3: DFT₃ with FMA twiddle multiplies */
    double o_re[3][2], o_im[3][2];
    for (int p = 0; p < 2; p++) {
        double ar = b_re[0][p], ai = b_im[0][p];
        double br = b_re[1][p], bi = b_im[1][p];
        double cr = b_re[2][p], ci = b_im[2][p];

        /* j=0: (a + b + c) / √3 */
        o_re[0][p] = N3 * (ar + br + cr);
        o_im[0][p] = N3 * (ai + bi + ci);

        /* j=1: (a + ω₃·b + ω₃²·c) / √3 — FMA twiddles */
        double wb_r = fma(-S32, bi, -0.5*br);
        double wb_i = fma( S32, br, -0.5*bi);
        double wc_r = fma( S32, ci, -0.5*cr);
        double wc_i = fma(-S32, cr, -0.5*ci);
        o_re[1][p] = N3 * (ar + wb_r + wc_r);
        o_im[1][p] = N3 * (ai + wb_i + wc_i);

        /* j=2: (a + ω₃²·b + ω₃·c) / √3 — conjugate */
        double w2b_r = fma( S32, bi, -0.5*br);
        double w2b_i = fma(-S32, br, -0.5*bi);
        double w2c_r = fma(-S32, ci, -0.5*cr);
        double w2c_i = fma( S32, cr, -0.5*ci);
        o_re[2][p] = N3 * (ar + w2b_r + w2c_r);
        o_im[2][p] = N3 * (ai + w2b_i + w2c_i);
    }

    /* P_out: (s,p) → j = s*2 + p */
    re[0] = o_re[0][0]; im[0] = o_im[0][0];
    re[1] = o_re[0][1]; im[1] = o_im[0][1];
    re[2] = o_re[1][0]; im[2] = o_im[1][0];
    re[3] = o_re[1][1]; im[3] = o_im[1][1];
    re[4] = o_re[2][0]; im[4] = o_im[2][0];
    re[5] = o_re[2][1]; im[5] = o_im[2][1];
}

/* ═══════════════════════════════════════════════════════════
 * APPLY INVERSE DFT₆ — Factored FMA (conjugate twiddles)
 *
 * Sidechannel probe: 15.4 ns (vs 27.9 ns naive 6×6 matmul)
 * Round-trip error: 1.11e-16 (vs 3.33e-16 naive)
 *
 * IDFT₆ = DFT₆† = reverse permutations, conjugate ω.
 * DFT₂† = DFT₂ (self-adjoint), ω₃* = (-0.5, -√3/2).
 * ═══════════════════════════════════════════════════════════ */

static inline void sup_apply_idft6(double *re, double *im) {
    static const double S32 = 0.86602540378443864676;
    static const double N3 = 0.57735026918962576451;
    static const double H = 0.70710678118654752440;

    /* Reverse P_out: j → (s,p) where s=j/2, p=j%2 */
    double b_re[3][2], b_im[3][2];
    b_re[0][0] = re[0]; b_im[0][0] = im[0];
    b_re[0][1] = re[1]; b_im[0][1] = im[1];
    b_re[1][0] = re[2]; b_im[1][0] = im[2];
    b_re[1][1] = re[3]; b_im[1][1] = im[3];
    b_re[2][0] = re[4]; b_im[2][0] = im[4];
    b_re[2][1] = re[5]; b_im[2][1] = im[5];

    /* Stage 3†: DFT₃† with conjugate ω₃* = (-0.5, -√3/2) */
    double o_re[3][2], o_im[3][2];
    for (int p = 0; p < 2; p++) {
        double ar = b_re[0][p], ai = b_im[0][p];
        double br = b_re[1][p], bi = b_im[1][p];
        double cr = b_re[2][p], ci = b_im[2][p];

        o_re[0][p] = N3 * (ar + br + cr);
        o_im[0][p] = N3 * (ai + bi + ci);

        /* ω₃*·b = (-0.5*br + √3/2*bi, -0.5*bi - √3/2*br) */
        double wb_r = fma( S32, bi, -0.5*br);
        double wb_i = fma(-S32, br, -0.5*bi);
        double wc_r = fma(-S32, ci, -0.5*cr);
        double wc_i = fma( S32, cr, -0.5*ci);
        o_re[1][p] = N3 * (ar + wb_r + wc_r);
        o_im[1][p] = N3 * (ai + wb_i + wc_i);

        double w2b_r = fma(-S32, bi, -0.5*br);
        double w2b_i = fma( S32, br, -0.5*bi);
        double w2c_r = fma( S32, ci, -0.5*cr);
        double w2c_i = fma(-S32, cr, -0.5*ci);
        o_re[2][p] = N3 * (ar + w2b_r + w2c_r);
        o_im[2][p] = N3 * (ai + w2b_i + w2c_i);
    }

    /* Stage 2†: Conjugate twiddle ω₆*^1 = (0.5, -√3/2) */
    {
        double r1 = o_re[1][1], i1 = o_im[1][1];
        o_re[1][1] = fma( S32, i1, 0.5*r1);
        o_im[1][1] = fma(-S32, r1, 0.5*i1);
        double r2 = o_re[2][1], i2 = o_im[2][1];
        o_re[2][1] = fma( S32, i2, -0.5*r2);
        o_im[2][1] = fma(-S32, r2, -0.5*i2);
    }

    /* Stage 1†: Hadamard (self-adjoint) */
    for (int s = 0; s < 3; s++) {
        double a = o_re[s][0], b = o_re[s][1];
        double c = o_im[s][0], d = o_im[s][1];
        o_re[s][0] = H*(a+b); o_im[s][0] = H*(c+d);
        o_re[s][1] = H*(a-b); o_im[s][1] = H*(c-d);
    }

    /* Reverse P_in: (s,p) → k = s + 3*p */
    re[0] = o_re[0][0]; im[0] = o_im[0][0];
    re[1] = o_re[1][0]; im[1] = o_im[1][0];
    re[2] = o_re[2][0]; im[2] = o_im[2][0];
    re[3] = o_re[0][1]; im[3] = o_im[0][1];
    re[4] = o_re[1][1]; im[4] = o_im[1][1];
    re[5] = o_re[2][1]; im[5] = o_im[2][1];
}

/* ═══════════════════════════════════════════════════════════
 * GENERAL DFT — For any dimension D
 *
 * Uses born_fast_isqrt for normalization.
 * Falls through to precomputed table for D=6.
 * ═══════════════════════════════════════════════════════════ */

static inline void sup_apply_dft(double *re, double *im, int D) {
    if (D == 6) { sup_apply_dft6(re, im); return; }
    double *new_re = (double*)calloc(D, sizeof(double));
    double *new_im = (double*)calloc(D, sizeof(double));
    double inv_sqrt_d = born_fast_isqrt((double)D);
    for (int j = 0; j < D; j++) {
        for (int k = 0; k < D; k++) {
            double angle = 2.0 * M_PI * j * k / (double)D;
            double tw_re = inv_sqrt_d * cos(angle);
            double tw_im = inv_sqrt_d * sin(angle);
            new_re[j] += tw_re * re[k] - tw_im * im[k];
            new_im[j] += tw_re * im[k] + tw_im * re[k];
        }
    }
    for (int k = 0; k < D; k++) { re[k] = new_re[k]; im[k] = new_im[k]; }
    free(new_re); free(new_im);
}

/* ═══════════════════════════════════════════════════════════
 * NORMALIZATION CHECK
 * ═══════════════════════════════════════════════════════════ */

static inline double sup_total_prob(const double *re, const double *im, int D) {
    double total = 0.0;
    for (int k = 0; k < D; k++)
        total += re[k]*re[k] + im[k]*im[k]; /* naive accumulation (matches reality) */
    return total;
}

/* ═══════════════════════════════════════════════════════════
 * RENORMALIZE — Fix rounding drift
 * ═══════════════════════════════════════════════════════════ */

static inline void sup_renormalize(double *re, double *im, int D) {
    double total = sup_total_prob(re, im, D);
    if (total > 0.0 && fabs(total - 1.0) > 1e-15) {
        double scale = born_fast_isqrt(total);
        for (int k = 0; k < D; k++) {
            re[k] *= scale;
            im[k] *= scale;
        }
    }
}

#endif /* SUPERPOSITION_H */
