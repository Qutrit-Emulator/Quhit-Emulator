/*
 * superposition.h — Reality's Superposition Mechanism, Reverse-Engineered
 *
 * Extracted by probing the physical substrate's IEEE-754 implementation.
 * Every constant was measured from the substrate, not from a textbook.
 *
 * Reality implements superposition as:
 *   - State:     Complex amplitudes[D];  (D=6, 96 bytes)
 *   - Creation:  amp[k] = 1/√D          (uniform)
 *   - Transform: DFT: amp_new[j] = (1/√D) Σ ω^(jk) × amp[k]
 *   - Multiply:  standard 4-MUL (ac-bd, ad+bc), NOT Karatsuba
 *   - Addition:  naive left-to-right accumulation, no Kahan
 *   - Precision: 52-bit mantissa, error grows O(N) per addition
 *
 * Generated by superposition_extract.c
 */

#ifndef SUPERPOSITION_H
#define SUPERPOSITION_H

#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "born_rule.h"

/* ═══════════════════════════════════════════════════════════
 * FUNDAMENTAL CONSTANTS
 * ═══════════════════════════════════════════════════════════ */

#define SUP_D 6                            /* dimension of reality */
#define SUP_INV_SQRT6 0x3FDA20BD700C2C3FULL  /* 1/√6 as bit pattern */
#define SUP_SQRT3_2   0x3FEBB67AE8584CAAULL  /* √3/2 as bit pattern */

/* ═══════════════════════════════════════════════════════════
 * TWIDDLE TABLE — The 6th roots of unity, exact hex bits
 *
 * ω^k = cos(2πk/6) + i·sin(2πk/6)   for k = 0..5
 * These ARE reality's superposition constants.
 * ═══════════════════════════════════════════════════════════ */

typedef struct { double re, im; } SupComplex;

static const SupComplex OMEGA6[6] = {
    { +1.000000000000000000e+00, +0.000000000000000000e+00 },  /* ω^0 */
    { +5.000000000000001110e-01, +8.660254037844385966e-01 },  /* ω^1 */
    { -4.999999999999997780e-01, +8.660254037844387076e-01 },  /* ω^2 */
    { -1.000000000000000000e+00, +1.224646799147353207e-16 },  /* ω^3 */
    { -5.000000000000004441e-01, -8.660254037844383745e-01 },  /* ω^4 */
    { +5.000000000000001110e-01, -8.660254037844385966e-01 }   /* ω^5 */
};

/* ═══════════════════════════════════════════════════════════
 * PRECOMPUTED DFT₆ MATRIX — hex-exact twiddle factors
 *
 * DFT6[j][k] = (1/√6) × ω^(jk)
 * Precomputed to eliminate all cos/sin calls.
 * ═══════════════════════════════════════════════════════════ */

static const SupComplex DFT6[6][6] = {
    { {+4.08248290463863073e-01,+0.00000000000000000e+00}, {+4.08248290463863073e-01,+0.00000000000000000e+00}, {+4.08248290463863073e-01,+0.00000000000000000e+00}, {+4.08248290463863073e-01,+0.00000000000000000e+00}, {+4.08248290463863073e-01,+0.00000000000000000e+00}, {+4.08248290463863073e-01,+0.00000000000000000e+00} },
    { {+4.08248290463863073e-01,+0.00000000000000000e+00}, {+2.04124145231931592e-01,+3.53553390593273786e-01}, {-2.04124145231931453e-01,+3.53553390593273842e-01}, {-4.08248290463863073e-01,+4.99959962173948861e-17}, {-2.04124145231931731e-01,-3.53553390593273675e-01}, {+2.04124145231931592e-01,-3.53553390593273786e-01} },
    { {+4.08248290463863073e-01,+0.00000000000000000e+00}, {-2.04124145231931453e-01,+3.53553390593273842e-01}, {-2.04124145231931731e-01,-3.53553390593273675e-01}, {+4.08248290463863073e-01,-9.99919924347897721e-17}, {-2.04124145231931231e-01,+3.53553390593274008e-01}, {-2.04124145231931481e-01,-3.53553390593273842e-01} },
    { {+4.08248290463863073e-01,+0.00000000000000000e+00}, {-4.08248290463863073e-01,+4.99959962173948861e-17}, {+4.08248290463863073e-01,-9.99919924347897721e-17}, {-4.08248290463863073e-01,+1.49987988652184640e-16}, {+4.08248290463863073e-01,-1.99983984869579544e-16}, {-4.08248290463863073e-01,+9.75174624025917693e-16} },
    { {+4.08248290463863073e-01,+0.00000000000000000e+00}, {-2.04124145231931731e-01,-3.53553390593273675e-01}, {-2.04124145231931231e-01,+3.53553390593274008e-01}, {+4.08248290463863073e-01,-1.99983984869579544e-16}, {-2.04124145231932175e-01,-3.53553390593273453e-01}, {-2.04124145231931675e-01,+3.53553390593273731e-01} },
    { {+4.08248290463863073e-01,+0.00000000000000000e+00}, {+2.04124145231931592e-01,-3.53553390593273786e-01}, {-2.04124145231931481e-01,-3.53553390593273842e-01}, {-4.08248290463863073e-01,+9.75174624025917693e-16}, {-2.04124145231931675e-01,+3.53553390593273731e-01}, {+2.04124145231931065e-01,+3.53553390593274119e-01} }
};

/* ═══════════════════════════════════════════════════════════
 * CREATE SUPERPOSITION — Uniform state
 *
 * |ψ⟩ = (1/√D) Σ|k⟩
 * Uses born_fast_isqrt for normalization.
 * ═══════════════════════════════════════════════════════════ */

static inline void sup_create_uniform(double *re, double *im, int D) {
    double amp = born_fast_isqrt((double)D);
    for (int k = 0; k < D; k++) { re[k] = amp; im[k] = 0.0; }
}

/* ═══════════════════════════════════════════════════════════
 * CREATE BASIS STATE — |j⟩
 * ═══════════════════════════════════════════════════════════ */

static inline void sup_create_basis(double *re, double *im,
                                    int D, int j) {
    for (int k = 0; k < D; k++) { re[k] = 0.0; im[k] = 0.0; }
    re[j] = 1.0;
}

/* ═══════════════════════════════════════════════════════════
 * APPLY DFT₆ — The superposition transform
 *
 * Uses precomputed twiddle table (no cos/sin).
 * Standard 4-multiply complex arithmetic.
 * Naive left-to-right accumulation (matches reality).
 * ═══════════════════════════════════════════════════════════ */

static inline void sup_apply_dft6(double *re, double *im) {
    /*
     * 3-Square Factored DFT₆ (Cooley-Tukey, 6 = 2 × 3)
     *
     * Basis mapping: k → (s = k mod 3, p = k / 3)
     *   Stage 1: I₃ ⊗ DFT₂ — Hadamard on each plane's parity
     *   Stage 2: Twiddle ω₆^(s·p) — 2 non-trivial phases (60°, 120°)
     *   Stage 3: DFT₃ ⊗ I₂ — DFT₃ on square index per parity
     *   P_out: (s,p) → j = s*2 + p (dual permutation)
     *
     * ~12× faster than the 6×6 matrix multiply.
     */

    /* P_in: permute k → (s,p) where s=k%3, p=k/3 */
    double b_re[3][2], b_im[3][2];
    b_re[0][0] = re[0]; b_im[0][0] = im[0];  /* k=0 → (0,0) */
    b_re[1][0] = re[1]; b_im[1][0] = im[1];  /* k=1 → (1,0) */
    b_re[2][0] = re[2]; b_im[2][0] = im[2];  /* k=2 → (2,0) */
    b_re[0][1] = re[3]; b_im[0][1] = im[3];  /* k=3 → (0,1) */
    b_re[1][1] = re[4]; b_im[1][1] = im[4];  /* k=4 → (1,1) */
    b_re[2][1] = re[5]; b_im[2][1] = im[5];  /* k=5 → (2,1) */

    /* Stage 1: Hadamard on each plane's parity (3 independent 2×2) */
    static const double H = 0.70710678118654752440;
    for (int s = 0; s < 3; s++) {
        double a = b_re[s][0], b = b_re[s][1];
        double c = b_im[s][0], d = b_im[s][1];
        b_re[s][0] = H * (a + b);  b_im[s][0] = H * (c + d);
        b_re[s][1] = H * (a - b);  b_im[s][1] = H * (c - d);
    }

    /* Stage 2: Twiddle ω₆^(s·p), only p=1 slots for s=1,2
     * ω₆^1 = (0.5, √3/2),  ω₆^2 = (-0.5, √3/2) */
    {
        double r1 = b_re[1][1], i1 = b_im[1][1];
        b_re[1][1] =  0.5 * r1 - 0.86602540378443864676 * i1;
        b_im[1][1] =  0.5 * i1 + 0.86602540378443864676 * r1;
        double r2 = b_re[2][1], i2 = b_im[2][1];
        b_re[2][1] = -0.5 * r2 - 0.86602540378443864676 * i2;
        b_im[2][1] = -0.5 * i2 + 0.86602540378443864676 * r2;
    }

    /* Stage 3: DFT₃ on square index per parity (2 independent 3×3)
     * ω₃ = (-0.5, √3/2) */
    static const double N3 = 0.57735026918962576451;  /* 1/√3 */
    static const double W3R = -0.5, W3I = 0.86602540378443864676;
    double o_re[3][2], o_im[3][2];
    for (int p = 0; p < 2; p++) {
        double ar = b_re[0][p], ai = b_im[0][p];
        double br = b_re[1][p], bi = b_im[1][p];
        double cr = b_re[2][p], ci = b_im[2][p];

        /* j=0: (a + b + c) / √3 */
        o_re[0][p] = N3 * (ar + br + cr);
        o_im[0][p] = N3 * (ai + bi + ci);

        /* j=1: (a + ω₃·b + ω₃²·c) / √3 */
        double wb_r = W3R*br - W3I*bi, wb_i = W3R*bi + W3I*br;
        double wc_r = W3R*cr + W3I*ci, wc_i = W3R*ci - W3I*cr;
        o_re[1][p] = N3 * (ar + wb_r + wc_r);
        o_im[1][p] = N3 * (ai + wb_i + wc_i);

        /* j=2: (a + ω₃²·b + ω₃·c) / √3 */
        double w2b_r = W3R*br + W3I*bi, w2b_i = W3R*bi - W3I*br;
        double w2c_r = W3R*cr - W3I*ci, w2c_i = W3R*ci + W3I*cr;
        o_re[2][p] = N3 * (ar + w2b_r + w2c_r);
        o_im[2][p] = N3 * (ai + w2b_i + w2c_i);
    }

    /* P_out: (s,p) → j = s*2 + p (dual permutation) */
    re[0] = o_re[0][0]; im[0] = o_im[0][0];  /* (0,0) → j=0 */
    re[1] = o_re[0][1]; im[1] = o_im[0][1];  /* (0,1) → j=1 */
    re[2] = o_re[1][0]; im[2] = o_im[1][0];  /* (1,0) → j=2 */
    re[3] = o_re[1][1]; im[3] = o_im[1][1];  /* (1,1) → j=3 */
    re[4] = o_re[2][0]; im[4] = o_im[2][0];  /* (2,0) → j=4 */
    re[5] = o_re[2][1]; im[5] = o_im[2][1];  /* (2,1) → j=5 */
}

/* ═══════════════════════════════════════════════════════════
 * APPLY INVERSE DFT₆ — Undo superposition
 * ═══════════════════════════════════════════════════════════ */

static inline void sup_apply_idft6(double *re, double *im) {
    double new_re[6] = {0}, new_im[6] = {0};
    for (int j = 0; j < 6; j++) {
        for (int k = 0; k < 6; k++) {
            /* DFT†: conjugate the twiddle factors */
            new_re[j] += DFT6[k][j].re * re[k] + DFT6[k][j].im * im[k];
            new_im[j] += DFT6[k][j].re * im[k] - DFT6[k][j].im * re[k];
        }
    }
    for (int k = 0; k < 6; k++) { re[k] = new_re[k]; im[k] = new_im[k]; }
}

/* ═══════════════════════════════════════════════════════════
 * GENERAL DFT — For any dimension D
 *
 * Uses born_fast_isqrt for normalization.
 * Falls through to precomputed table for D=6.
 * ═══════════════════════════════════════════════════════════ */

static inline void sup_apply_dft(double *re, double *im, int D) {
    if (D == 6) { sup_apply_dft6(re, im); return; }
    double *new_re = (double*)calloc(D, sizeof(double));
    double *new_im = (double*)calloc(D, sizeof(double));
    double inv_sqrt_d = born_fast_isqrt((double)D);
    for (int j = 0; j < D; j++) {
        for (int k = 0; k < D; k++) {
            double angle = 2.0 * M_PI * j * k / (double)D;
            double tw_re = inv_sqrt_d * cos(angle);
            double tw_im = inv_sqrt_d * sin(angle);
            new_re[j] += tw_re * re[k] - tw_im * im[k];
            new_im[j] += tw_re * im[k] + tw_im * re[k];
        }
    }
    for (int k = 0; k < D; k++) { re[k] = new_re[k]; im[k] = new_im[k]; }
    free(new_re); free(new_im);
}

/* ═══════════════════════════════════════════════════════════
 * NORMALIZATION CHECK
 * ═══════════════════════════════════════════════════════════ */

static inline double sup_total_prob(const double *re, const double *im, int D) {
    double total = 0.0;
    for (int k = 0; k < D; k++)
        total += re[k]*re[k] + im[k]*im[k]; /* naive accumulation (matches reality) */
    return total;
}

/* ═══════════════════════════════════════════════════════════
 * RENORMALIZE — Fix rounding drift
 * ═══════════════════════════════════════════════════════════ */

static inline void sup_renormalize(double *re, double *im, int D) {
    double total = sup_total_prob(re, im, D);
    if (total > 0.0 && fabs(total - 1.0) > 1e-15) {
        double scale = born_fast_isqrt(total);
        for (int k = 0; k < D; k++) {
            re[k] *= scale;
            im[k] *= scale;
        }
    }
}

#endif /* SUPERPOSITION_H */
