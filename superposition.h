/*
 * superposition.h — Reality's Superposition Mechanism, Reverse-Engineered
 *
 * Extracted by probing the physical substrate's IEEE-754 implementation.
 * Every constant was measured from the substrate, not from a textbook.
 *
 * Reality implements superposition as:
 *   - State:     Complex amplitudes[D];  (D=6, 96 bytes)
 *   - Creation:  amp[k] = 1/√D          (uniform)
 *   - Transform: DFT: amp_new[j] = (1/√D) Σ ω^(jk) × amp[k]
 *   - Multiply:  standard 4-MUL (ac-bd, ad+bc), NOT Karatsuba
 *   - Addition:  naive left-to-right accumulation, no Kahan
 *   - Precision: 52-bit mantissa, error grows O(N) per addition
 *
 * Generated by superposition_extract.c
 */

#ifndef SUPERPOSITION_H
#define SUPERPOSITION_H

#include <stdint.h>
#include <string.h>
#include <math.h>
#include "born_rule.h"

/* ═══════════════════════════════════════════════════════════
 * FUNDAMENTAL CONSTANTS
 * ═══════════════════════════════════════════════════════════ */

#define SUP_D 6                            /* dimension of reality */
#define SUP_INV_SQRT6 0x3FDA20BD700C2C3FULL  /* 1/√6 as bit pattern */
#define SUP_SQRT3_2   0x3FEBB67AE8584CAAULL  /* √3/2 as bit pattern */

/* ═══════════════════════════════════════════════════════════
 * TWIDDLE TABLE — The 6th roots of unity, exact hex bits
 *
 * ω^k = cos(2πk/6) + i·sin(2πk/6)   for k = 0..5
 * These ARE reality's superposition constants.
 * ═══════════════════════════════════════════════════════════ */

typedef struct { double re, im; } SupComplex;

static const SupComplex OMEGA6[6] = {
    { +1.000000000000000000e+00, +0.000000000000000000e+00 },  /* ω^0 */
    { +5.000000000000001110e-01, +8.660254037844385966e-01 },  /* ω^1 */
    { -4.999999999999997780e-01, +8.660254037844387076e-01 },  /* ω^2 */
    { -1.000000000000000000e+00, +1.224646799147353207e-16 },  /* ω^3 */
    { -5.000000000000004441e-01, -8.660254037844383745e-01 },  /* ω^4 */
    { +5.000000000000001110e-01, -8.660254037844385966e-01 }   /* ω^5 */
};

/* ═══════════════════════════════════════════════════════════
 * PRECOMPUTED DFT₆ MATRIX — hex-exact twiddle factors
 *
 * DFT6[j][k] = (1/√6) × ω^(jk)
 * Precomputed to eliminate all cos/sin calls.
 * ═══════════════════════════════════════════════════════════ */

static const SupComplex DFT6[6][6] = {
    { {+4.08248290463863073e-01,+0.00000000000000000e+00}, {+4.08248290463863073e-01,+0.00000000000000000e+00}, {+4.08248290463863073e-01,+0.00000000000000000e+00}, {+4.08248290463863073e-01,+0.00000000000000000e+00}, {+4.08248290463863073e-01,+0.00000000000000000e+00}, {+4.08248290463863073e-01,+0.00000000000000000e+00} },
    { {+4.08248290463863073e-01,+0.00000000000000000e+00}, {+2.04124145231931592e-01,+3.53553390593273786e-01}, {-2.04124145231931453e-01,+3.53553390593273842e-01}, {-4.08248290463863073e-01,+4.99959962173948861e-17}, {-2.04124145231931731e-01,-3.53553390593273675e-01}, {+2.04124145231931592e-01,-3.53553390593273786e-01} },
    { {+4.08248290463863073e-01,+0.00000000000000000e+00}, {-2.04124145231931453e-01,+3.53553390593273842e-01}, {-2.04124145231931731e-01,-3.53553390593273675e-01}, {+4.08248290463863073e-01,-9.99919924347897721e-17}, {-2.04124145231931231e-01,+3.53553390593274008e-01}, {-2.04124145231931481e-01,-3.53553390593273842e-01} },
    { {+4.08248290463863073e-01,+0.00000000000000000e+00}, {-4.08248290463863073e-01,+4.99959962173948861e-17}, {+4.08248290463863073e-01,-9.99919924347897721e-17}, {-4.08248290463863073e-01,+1.49987988652184640e-16}, {+4.08248290463863073e-01,-1.99983984869579544e-16}, {-4.08248290463863073e-01,+9.75174624025917693e-16} },
    { {+4.08248290463863073e-01,+0.00000000000000000e+00}, {-2.04124145231931731e-01,-3.53553390593273675e-01}, {-2.04124145231931231e-01,+3.53553390593274008e-01}, {+4.08248290463863073e-01,-1.99983984869579544e-16}, {-2.04124145231932175e-01,-3.53553390593273453e-01}, {-2.04124145231931675e-01,+3.53553390593273731e-01} },
    { {+4.08248290463863073e-01,+0.00000000000000000e+00}, {+2.04124145231931592e-01,-3.53553390593273786e-01}, {-2.04124145231931481e-01,-3.53553390593273842e-01}, {-4.08248290463863073e-01,+9.75174624025917693e-16}, {-2.04124145231931675e-01,+3.53553390593273731e-01}, {+2.04124145231931065e-01,+3.53553390593274119e-01} }
};

/* ═══════════════════════════════════════════════════════════
 * CREATE SUPERPOSITION — Uniform state
 *
 * |ψ⟩ = (1/√D) Σ|k⟩
 * Uses born_fast_isqrt for normalization.
 * ═══════════════════════════════════════════════════════════ */

static inline void sup_create_uniform(double *re, double *im, int D) {
    double amp = born_fast_isqrt((double)D);
    for (int k = 0; k < D; k++) { re[k] = amp; im[k] = 0.0; }
}

/* ═══════════════════════════════════════════════════════════
 * CREATE BASIS STATE — |j⟩
 * ═══════════════════════════════════════════════════════════ */

static inline void sup_create_basis(double *re, double *im,
                                    int D, int j) {
    for (int k = 0; k < D; k++) { re[k] = 0.0; im[k] = 0.0; }
    re[j] = 1.0;
}

/* ═══════════════════════════════════════════════════════════
 * APPLY DFT₆ — The superposition transform
 *
 * Uses precomputed twiddle table (no cos/sin).
 * Standard 4-multiply complex arithmetic.
 * Naive left-to-right accumulation (matches reality).
 * ═══════════════════════════════════════════════════════════ */

static inline void sup_apply_dft6(double *re, double *im) {
    double new_re[6] = {0}, new_im[6] = {0};
    for (int j = 0; j < 6; j++) {
        for (int k = 0; k < 6; k++) {
            /* Standard 4-multiply: (a+bi)(c+di) = (ac-bd)+(ad+bc)i */
            new_re[j] += DFT6[j][k].re * re[k] - DFT6[j][k].im * im[k];
            new_im[j] += DFT6[j][k].re * im[k] + DFT6[j][k].im * re[k];
        }
    }
    for (int k = 0; k < 6; k++) { re[k] = new_re[k]; im[k] = new_im[k]; }
}

/* ═══════════════════════════════════════════════════════════
 * APPLY INVERSE DFT₆ — Undo superposition
 * ═══════════════════════════════════════════════════════════ */

static inline void sup_apply_idft6(double *re, double *im) {
    double new_re[6] = {0}, new_im[6] = {0};
    for (int j = 0; j < 6; j++) {
        for (int k = 0; k < 6; k++) {
            /* DFT†: conjugate the twiddle factors */
            new_re[j] += DFT6[k][j].re * re[k] + DFT6[k][j].im * im[k];
            new_im[j] += DFT6[k][j].re * im[k] - DFT6[k][j].im * re[k];
        }
    }
    for (int k = 0; k < 6; k++) { re[k] = new_re[k]; im[k] = new_im[k]; }
}

/* ═══════════════════════════════════════════════════════════
 * GENERAL DFT — For any dimension D
 *
 * Uses born_fast_isqrt for normalization.
 * Falls through to precomputed table for D=6.
 * ═══════════════════════════════════════════════════════════ */

static inline void sup_apply_dft(double *re, double *im, int D) {
    if (D == 6) { sup_apply_dft6(re, im); return; }
    double *new_re = (double*)calloc(D, sizeof(double));
    double *new_im = (double*)calloc(D, sizeof(double));
    double inv_sqrt_d = born_fast_isqrt((double)D);
    for (int j = 0; j < D; j++) {
        for (int k = 0; k < D; k++) {
            double angle = 2.0 * M_PI * j * k / (double)D;
            double tw_re = inv_sqrt_d * cos(angle);
            double tw_im = inv_sqrt_d * sin(angle);
            new_re[j] += tw_re * re[k] - tw_im * im[k];
            new_im[j] += tw_re * im[k] + tw_im * re[k];
        }
    }
    for (int k = 0; k < D; k++) { re[k] = new_re[k]; im[k] = new_im[k]; }
    free(new_re); free(new_im);
}

/* ═══════════════════════════════════════════════════════════
 * NORMALIZATION CHECK
 * ═══════════════════════════════════════════════════════════ */

static inline double sup_total_prob(const double *re, const double *im, int D) {
    double total = 0.0;
    for (int k = 0; k < D; k++)
        total += re[k]*re[k] + im[k]*im[k]; /* naive accumulation (matches reality) */
    return total;
}

/* ═══════════════════════════════════════════════════════════
 * RENORMALIZE — Fix rounding drift
 * ═══════════════════════════════════════════════════════════ */

static inline void sup_renormalize(double *re, double *im, int D) {
    double total = sup_total_prob(re, im, D);
    if (total > 0.0 && fabs(total - 1.0) > 1e-15) {
        double scale = born_fast_isqrt(total);
        for (int k = 0; k < D; k++) {
            re[k] *= scale;
            im[k] *= scale;
        }
    }
}

#endif /* SUPERPOSITION_H */
