/*
 * entanglement.h — Reality's Entanglement Storage, Reverse-Engineered
 *
 * Extracted by probing the physical substrate.
 *
 * Reality stores entangled states as:
 *   - Layout:      flat Complex[D_A × D_B], row-major
 *   - Indexing:    ψ(a,b) = state[a * D_B + b]
 *   - Stride A:    D_B × 16 bytes (slow, strided)
 *   - Stride B:    16 bytes (fast, sequential)
 *   - No compression: product states use same memory as entangled
 *   - Entanglement is EMERGENT from amplitude VALUES, not storage
 *
 * Generated by entanglement_extract.c
 */

#ifndef ENTANGLEMENT_H
#define ENTANGLEMENT_H

#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "born_rule.h"
#include "statevector.h"

/* ═══════════════════════════════════════════════════════════
 * SUBSTRATE CONSTANTS
 * ═══════════════════════════════════════════════════════════ */

#define ENT_STRIDE_INNER  16   /* bytes: stride for inner (B) index */
#define ENT_LAYOUT_ROW_MAJOR 1 /* C-style: a*D_B + b */

/* ═══════════════════════════════════════════════════════════
 * JOINT STATE — Tensor product storage
 * ═══════════════════════════════════════════════════════════ */

typedef struct {
    double *re;         /* real parts: re[a*dim_b + b] */
    double *im;         /* imag parts: im[a*dim_b + b] */
    uint32_t dim_a;     /* dimension of subsystem A */
    uint32_t dim_b;     /* dimension of subsystem B */
    uint64_t total;     /* dim_a × dim_b */
} JointState;

/* ═══════════════════════════════════════════════════════════
 * ALLOCATE — cache-aligned joint state
 * ═══════════════════════════════════════════════════════════ */

static inline JointState ent_alloc(uint32_t dim_a, uint32_t dim_b) {
    JointState js;
    js.dim_a = dim_a;
    js.dim_b = dim_b;
    js.total = (uint64_t)dim_a * dim_b;
    js.re = (double*)sv_calloc_aligned(js.total, sizeof(double));
    js.im = (double*)sv_calloc_aligned(js.total, sizeof(double));
    return js;
}

static inline void ent_free(JointState *js) {
    free(js->re); free(js->im);
    js->re = NULL; js->im = NULL;
    js->total = 0;
}

/* ═══════════════════════════════════════════════════════════
 * ACCESS — O(1) indexing: state[a * dim_b + b]
 * ═══════════════════════════════════════════════════════════ */

#define ENT_IDX(js, a, b)  ((uint64_t)(a) * (js)->dim_b + (b))

/* ═══════════════════════════════════════════════════════════
 * CREATE BELL STATE — (1/√D) Σ|k⟩|k⟩
 * ═══════════════════════════════════════════════════════════ */

static inline void ent_create_bell(JointState *js) {
    memset(js->re, 0, js->total * sizeof(double));
    memset(js->im, 0, js->total * sizeof(double));
    uint32_t D = js->dim_a < js->dim_b ? js->dim_a : js->dim_b;
    double amp = born_fast_isqrt((double)D);
    for (uint32_t k = 0; k < D; k++)
        js->re[ENT_IDX(js, k, k)] = amp;
}

/* ═══════════════════════════════════════════════════════════
 * CREATE PRODUCT STATE — |α⟩ ⊗ |β⟩
 * ═══════════════════════════════════════════════════════════ */

static inline void ent_create_product(JointState *js,
        const double *a_re, const double *a_im,
        const double *b_re, const double *b_im) {
    for (uint32_t a = 0; a < js->dim_a; a++)
        for (uint32_t b = 0; b < js->dim_b; b++) {
            uint64_t idx = ENT_IDX(js, a, b);
            js->re[idx] = fma(a_re[a], b_re[b], -(a_im[a]*b_im[b]));
            js->im[idx] = fma(a_re[a], b_im[b],   a_im[a]*b_re[b]);
        }
}

/* ═══════════════════════════════════════════════════════════
 * PARTIAL TRACE — Tr_B(|ψ⟩⟨ψ|) → ρ_A
 *
 * ρ_A[i][j] = Σ_b ψ(i,b) × ψ*(j,b)
 *
 * Sidechannel probe: loop order (b,i,j) + FMA = 1.33× faster
 * than original (i,j,b). B in outermost → both i,j reads
 * share the same b offset → better cache locality.
 * ═══════════════════════════════════════════════════════════ */

static inline void ent_partial_trace_B(const JointState *js,
        double *rho_re, double *rho_im) {
    uint32_t da = js->dim_a, db = js->dim_b;
    memset(rho_re, 0, (size_t)da * da * sizeof(double));
    memset(rho_im, 0, (size_t)da * da * sizeof(double));
    for (uint32_t b = 0; b < db; b++)
        for (uint32_t i = 0; i < da; i++) {
            uint64_t ib = (uint64_t)i*db + b;
            double ri = js->re[ib], ii = js->im[ib];
            for (uint32_t j = 0; j < da; j++) {
                uint64_t jb = (uint64_t)j*db + b;
                /* ρ[i,j] += ψ(i,b) × conj(ψ(j,b)) — FMA */
                rho_re[i*da+j] = fma(ri, js->re[jb], fma(ii, js->im[jb], rho_re[i*da+j]));
                rho_im[i*da+j] = fma(ri, js->im[jb], rho_im[i*da+j]) - ii*js->re[jb];
            }
        }
}

/* ═══════════════════════════════════════════════════════════
 * DIAGONAL PARTIAL TRACE — diag(ρ_A) only
 *
 * diag[k] = Σ_b |ψ(k,b)|²
 * 7.55× faster than full partial trace for entropy/rank:
 * no off-diagonal computation, no heap allocation.
 * ═══════════════════════════════════════════════════════════ */

static inline void ent_partial_trace_diag(const JointState *js,
                                          double *diag) {
    uint32_t da = js->dim_a, db = js->dim_b;
    for (uint32_t k = 0; k < da; k++) {
        double sum = 0;
        for (uint32_t b = 0; b < db; b++) {
            uint64_t kb = (uint64_t)k*db + b;
            sum += js->re[kb]*js->re[kb] + js->im[kb]*js->im[kb];
        }
        diag[k] = sum;
    }
}

/* ═══════════════════════════════════════════════════════════
 * SCHMIDT RANK — number of nonzero Schmidt coefficients
 *
 * = 1 for product states, = D for maximally entangled.
 * Uses diagonal-only trace (no full matrix needed).
 * ═══════════════════════════════════════════════════════════ */

static inline int ent_schmidt_rank(const JointState *js) {
    double diag[6];  /* stack: D=6 max, 48 bytes */
    ent_partial_trace_diag(js, diag);
    int rank = 0;
    for (uint32_t k = 0; k < js->dim_a; k++)
        if (diag[k] > 1e-14) rank++;
    return rank;
}

/* ═══════════════════════════════════════════════════════════
 * ENTANGLEMENT ENTROPY — S = -Σ λ² log₂(λ²)
 *
 * Sidechannel probe: 42.9 ns (vs 323.4 ns) = 7.55× speedup
 * Uses diagonal-only trace + stack allocation.
 * ═══════════════════════════════════════════════════════════ */

static inline double ent_entropy(const JointState *js) {
    double diag[6];  /* stack: D=6 max, 48 bytes */
    ent_partial_trace_diag(js, diag);
    double S = 0.0;
    for (uint32_t k = 0; k < js->dim_a; k++) {
        if (diag[k] > 1e-14)
            S -= diag[k] * log2(diag[k]);
    }
    return S;
}

#endif /* ENTANGLEMENT_H */
