/*
 * entanglement.h — Reality's Entanglement Storage, Reverse-Engineered
 *
 * Extracted by probing the physical substrate.
 *
 * Reality stores entangled states as:
 *   - Layout:      flat Complex[D_A × D_B], row-major
 *   - Indexing:    ψ(a,b) = state[a * D_B + b]
 *   - Stride A:    D_B × 16 bytes (slow, strided)
 *   - Stride B:    16 bytes (fast, sequential)
 *   - No compression: product states use same memory as entangled
 *   - Entanglement is EMERGENT from amplitude VALUES, not storage
 *
 * Generated by entanglement_extract.c
 */

#ifndef ENTANGLEMENT_H
#define ENTANGLEMENT_H

#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "born_rule.h"
#include "statevector.h"

/* ═══════════════════════════════════════════════════════════
 * SUBSTRATE CONSTANTS
 * ═══════════════════════════════════════════════════════════ */

#define ENT_STRIDE_INNER  16   /* bytes: stride for inner (B) index */
#define ENT_LAYOUT_ROW_MAJOR 1 /* C-style: a*D_B + b */

/* ═══════════════════════════════════════════════════════════
 * JOINT STATE — Tensor product storage
 * ═══════════════════════════════════════════════════════════ */

typedef struct {
    double *re;         /* real parts: re[a*dim_b + b] */
    double *im;         /* imag parts: im[a*dim_b + b] */
    uint32_t dim_a;     /* dimension of subsystem A */
    uint32_t dim_b;     /* dimension of subsystem B */
    uint64_t total;     /* dim_a × dim_b */
} JointState;

/* ═══════════════════════════════════════════════════════════
 * ALLOCATE — cache-aligned joint state
 * ═══════════════════════════════════════════════════════════ */

static inline JointState ent_alloc(uint32_t dim_a, uint32_t dim_b) {
    JointState js;
    js.dim_a = dim_a;
    js.dim_b = dim_b;
    js.total = (uint64_t)dim_a * dim_b;
    js.re = (double*)sv_calloc_aligned(js.total, sizeof(double));
    js.im = (double*)sv_calloc_aligned(js.total, sizeof(double));
    return js;
}

static inline void ent_free(JointState *js) {
    free(js->re); free(js->im);
    js->re = NULL; js->im = NULL;
    js->total = 0;
}

/* ═══════════════════════════════════════════════════════════
 * ACCESS — O(1) indexing: state[a * dim_b + b]
 * ═══════════════════════════════════════════════════════════ */

#define ENT_IDX(js, a, b)  ((uint64_t)(a) * (js)->dim_b + (b))

/* ═══════════════════════════════════════════════════════════
 * CREATE BELL STATE — (1/√D) Σ|k⟩|k⟩
 * ═══════════════════════════════════════════════════════════ */

static inline void ent_create_bell(JointState *js) {
    memset(js->re, 0, js->total * sizeof(double));
    memset(js->im, 0, js->total * sizeof(double));
    uint32_t D = js->dim_a < js->dim_b ? js->dim_a : js->dim_b;
    double amp = born_fast_isqrt((double)D);
    for (uint32_t k = 0; k < D; k++)
        js->re[ENT_IDX(js, k, k)] = amp;
}

/* ═══════════════════════════════════════════════════════════
 * CREATE PRODUCT STATE — |α⟩ ⊗ |β⟩
 * ═══════════════════════════════════════════════════════════ */

static inline void ent_create_product(JointState *js,
        const double *a_re, const double *a_im,
        const double *b_re, const double *b_im) {
    for (uint32_t a = 0; a < js->dim_a; a++)
        for (uint32_t b = 0; b < js->dim_b; b++) {
            uint64_t idx = ENT_IDX(js, a, b);
            js->re[idx] = a_re[a]*b_re[b] - a_im[a]*b_im[b];
            js->im[idx] = a_re[a]*b_im[b] + a_im[a]*b_re[b];
        }
}

/* ═══════════════════════════════════════════════════════════
 * PARTIAL TRACE — Tr_B(|ψ⟩⟨ψ|) → ρ_A
 *
 * ρ_A[i][j] = Σ_b ψ(i,b) × ψ*(j,b)
 * Row-scan on B (sequential = cache-friendly).
 * ═══════════════════════════════════════════════════════════ */

static inline void ent_partial_trace_B(const JointState *js,
        double *rho_re, double *rho_im) {
    uint32_t da = js->dim_a, db = js->dim_b;
    memset(rho_re, 0, (size_t)da * da * sizeof(double));
    memset(rho_im, 0, (size_t)da * da * sizeof(double));
    for (uint32_t i = 0; i < da; i++)
        for (uint32_t j = 0; j < da; j++)
            for (uint32_t b = 0; b < db; b++) {
                uint64_t ib = (uint64_t)i*db+b, jb = (uint64_t)j*db+b;
                /* ρ[i,j] += ψ(i,b) × conj(ψ(j,b)) */
                rho_re[i*da+j] += js->re[ib]*js->re[jb] + js->im[ib]*js->im[jb];
                rho_im[i*da+j] += js->re[ib]*js->im[jb] - js->im[ib]*js->re[jb];
            }
}

/* ═══════════════════════════════════════════════════════════
 * SCHMIDT RANK — number of nonzero Schmidt coefficients
 *
 * = 1 for product states, = D for maximally entangled.
 * Computed from eigenvalues of ρ_A.
 * ═══════════════════════════════════════════════════════════ */

static inline int ent_schmidt_rank(const JointState *js) {
    uint32_t da = js->dim_a;
    double *rho_re = (double*)sv_calloc_aligned(da*da, sizeof(double));
    double *rho_im = (double*)sv_calloc_aligned(da*da, sizeof(double));
    ent_partial_trace_B(js, rho_re, rho_im);
    int rank = 0;
    for (uint32_t k = 0; k < da; k++)
        if (rho_re[k*da+k] > 1e-14) rank++;
    free(rho_re); free(rho_im);
    return rank;
}

/* ═══════════════════════════════════════════════════════════
 * ENTANGLEMENT ENTROPY — S = -Σ λ² log₂(λ²)
 * ═══════════════════════════════════════════════════════════ */

static inline double ent_entropy(const JointState *js) {
    uint32_t da = js->dim_a;
    double *rho_re = (double*)sv_calloc_aligned(da*da, sizeof(double));
    double *rho_im = (double*)sv_calloc_aligned(da*da, sizeof(double));
    ent_partial_trace_B(js, rho_re, rho_im);
    double S = 0.0;
    for (uint32_t k = 0; k < da; k++) {
        double lam2 = rho_re[k*da+k];
        if (lam2 > 1e-14)
            S -= lam2 * log2(lam2);
    }
    free(rho_re); free(rho_im);
    return S;
}

#endif /* ENTANGLEMENT_H */
